import os
import numpy as np
import nibabel as nib
from mesh import mesh_to_precomputed
from nifti import get_image_offset, get_image_resolution
import math
from utils import get_segid 
import concurrent.futures
from scipy.interpolate import interpn
from precomputed_io import create_segmentation_dir, write_segment_properties_info, write_segmentation_base_info
from nii_to_geometry import nii_to_vertice_and_faces
from color_tools import normalized_to_single_color_map, normalized_to_two_color_maps
import sys

"""
  Obtain the coordinates of vertices in the image through the interpolation function
"""
def interpolate_vertices_to_image(vertices, selected_image):
  x_size, y_size, z_size = selected_image.header.get_data_shape()
  affine = selected_image.header.get_best_affine()
  srow_x = affine[0]
  srow_y = affine[1]
  srow_z = affine[2]
  
  x_index = list(range(int(srow_x[3]), x_size * int(srow_x[0]) + int(srow_x[3]), int(srow_x[0])))
  y_index = list(range(int(srow_y[3]), y_size * int(srow_y[1]) + int(srow_y[3]), int(srow_y[1])))
  z_index = list(range(int(srow_z[3]), z_size * int(srow_z[2]) + int(srow_z[3]), int(srow_z[2])))

  v_index = interpn((x_index, y_index, z_index), selected_image.get_fdata(), vertices, bounds_error=False, fill_value=0)

  return v_index



def project_image_onto_surface(target_dir, image, vertices, faces, cmap_name="blue-lightblue", cmaps_type="fsleyes", project_type="single", reverse=False):
  segid = get_segid(image)

  selected_image = nib.load(image)

  v_index = interpolate_vertices_to_image(vertices, selected_image)

  match project_type:
    case 'two_cmaps':
      color_v = normalized_to_two_color_maps(v_index)
    case _:
      color_v = normalized_to_single_color_map(v_index, cmap_name=cmap_name, cmaps_type=cmaps_type, reverse=reverse)

  ## write to precomputed
  image_offset = get_image_offset(image)
  image_resolution = get_image_resolution(image)

  mesh_to_precomputed(
    target_dir,
    segid,
    vertices, 
    faces, 
    color_v, 
    image_offset=[math.fabs(o) for o in image_offset],
    image_resolution=image_resolution)
  
  return [segid, image_resolution, selected_image.header.get_data_shape()]


"""
  get vertices and faces from surface_file
"""
def parse_surface(surface_file):
  file_ext = ".".join(os.path.basename(surface_file).split(".")[1:])
  match file_ext:
    case "surf":
      vertice_num = np.loadtxt(surface_file, max_rows=1, dtype=np.uint32)[0]
      vertices = np.loadtxt(surface_file, skiprows=1, max_rows=vertice_num, dtype=np.float32)
      faces = np.loadtxt(surface_file, skiprows=2+vertice_num, dtype=np.uint32)
      return [vertices, faces - 1]
    case "nii.gz":
      vertices, faces = nii_to_vertice_and_faces(surface_file)
      return [vertices, faces]
    case _:
      raise TypeError(f"Not support *.{file_ext}")


"""
  project images value onto a mesh surface generated by itself
"""
def project_images_onto_self(root_dir, images_dir, project_type="single", **args):
  root_path = create_segmentation_dir(root_dir)
  images_list = sorted(os.listdir(images_dir))
  print(images_list)
  ids = []
  for image in images_list:
    image_file = os.path.join(images_dir, image)
    vertices, faces = parse_surface(image_file)
    segid, resolution, size = project_image_onto_surface(
      f'{root_path}/mesh', 
      image_file, 
      vertices,
      faces,
      project_type=project_type,
      **args)
    ids.append(segid)
  write_segment_properties_info(f'{root_path}/segment_properties', ids=ids, labels=ids)
  write_segmentation_base_info(root_path, resolution, size)

"""
  project images value onto an input surface
"""
def project_images_onto_other(root_dir, surface_file, images_dir, project_type="single", **args):
  root_path = create_segmentation_dir(root_dir)
  images_list = sorted(os.listdir(images_dir))
  ids = []
  vertices, faces = parse_surface(surface_file)
  with concurrent.futures.ThreadPoolExecutor(10) as executor:
    future_to_img = { executor.submit(
        project_image_onto_surface,
        f'{root_path}/mesh', 
        os.path.join(images_dir, image_file), 
        vertices, 
        faces, project_type=project_type): image_file for image_file in images_list }
    for future in concurrent.futures.as_completed(future_to_img):
      segid, resolution, size = future.result()
      ids.append(segid)
  write_segment_properties_info(f'{root_path}/segment_properties', ids=ids, labels=ids)
  write_segmentation_base_info(root_path, resolution, size)


if __name__ == "__main__":
  images_dir = sys.argv[1]
  root_dir = sys.argv[2]
  surface_file = sys.argv[3]
  #project_images_onto_self(root_dir, images_dir)
  project_images_onto_other(root_dir, surface_file, images_dir, project_type="two_cmaps")




  


